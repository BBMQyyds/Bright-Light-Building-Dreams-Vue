[
  [
    {
      "id": 1,
      "type": "Vue",
      "title": "vue3使用keep-alive缓存界面",
      "code": "<router-view v-slot=\"{ Component }\" v-wechat-title=\"$route.meta.title\">\n  <keep-alive>\n    <component :is=\"Component\" v-if=\"$route.meta.keepAlive\" :key=\"$route.path\"/>\n  </keep-alive>\n  <component :is=\"Component\" v-if=\"!$route.meta.keepAlive\" :key=\"$route.path\"/>\n</router-view>"
    },
    {
      "id": 2,
      "type": "Vue",
      "title": "axios请求重发",
      "code": "// 添加一个响应拦截器，用于处理请求失败时的重试\nrequest.interceptors.response.use(undefined, function axiosRetryInterceptor(err) {\n    let config = err.config;\n\n    // 如果配置不存在或者retry选项未设置，拒绝promise\n    if (!config || !config.retry) {\n        return Promise.reject(err);\n    }\n\n    // 设置重试次数，默认为3\n    config.__retryCount = config.__retryCount || 0;\n\n    // 检查是否达到了最大重试次数\n    if (config.__retryCount >= config.retry) {\n        return Promise.reject(err);\n    }\n\n    // 增加重试次数\n    config.__retryCount += 1;\n\n    // 创建一个新的Promise，以延迟重试\n    let backoff = new Promise(function (resolve) {\n        setTimeout(function () {\n            resolve();\n        }, config.retryDelay || 1);\n    });\n\n    // 返回一个延迟后重试请求\n    return backoff.then(function () {\n        return request(config);\n    });\n});"
    },
    {
      "id": 3,
      "type": "Vue",
      "title": "axios取消请求",
      "code": "fileRequest.interceptors.request.use(config => {\n    //发起请求时保存页面所有请求\n    config.cancelToken = new axios.CancelToken(cancel => {\n        store.commit('pushToken', cancel);\n    });\n    return config\n});"
    },
    {
      "id": 4,
      "type": "Vue",
      "title": "vue3利用Activated重发未完成的请求",
      "code": "activated() {\n    if (this.recommendList.length === 0) {\n      this.getRecommendList();\n    } else {\n      this.recommendList.forEach(item => {\n        if (!this.$resource.isLoaded(item.img)) {\n          this.$resource.getInterface(item);\n        }\n      })\n    }\n    if (this.hotAuthorList.length === 0) {\n      this.getHotAuthorList();\n    } else {\n      this.hotAuthorList.forEach(item => {\n        if (!this.$resource.isLoaded(item.img)) {\n          this.$resource.getAvatar(item);\n        }\n      })\n    }\n    if (this.newSegmentList.length === 0) {\n      this.getNewSegmentList();\n    }\n  }"
    },
    {
      "id": 5,
      "type": "Vue",
      "title": "工具类封装以及资源工具方法",
      "code": "export default {\n    // 判断图片是否加载完成\n    isLoaded(src) {\n        if (src === null || src === undefined) {\n            return false;\n        }\n        let img = new Image();\n        img.src = src;\n        return img.complete;\n    },\n    getAvatar(item) {\n        fileRequest.post('/download', JSON.stringify({\n            apiType: aes.encrypt('downloadUserAvatar'),\n            data: aes.encrypt(item.avatar),\n        }), {\n            responseType: 'arraybuffer', // 指定响应类型为字节数组\n        }).then(response => {\n            // 将字节数组转换为Blob对象\n            const blob = new Blob([response.data], {type: response.headers['content-type']});\n            // 将Blob对象转换为DataURL\n            // 在界面中显示图像\n            item.img = URL.createObjectURL(blob);\n        }).catch((err => {\n            console.log(err);\n        }));\n    },\n\n    getInterface(item) {\n        fileRequest.post('/download', JSON.stringify({\n            apiType: aes.encrypt('downloadTaleInterface'),\n            data: aes.encrypt(item.face),\n        }), {\n            responseType: 'arraybuffer', // 指定响应类型为字节数组\n        }).then(response => {\n            // 将字节数组转换为Blob对象\n            const blob = new Blob([response.data], {type: response.headers['content-type']});\n            // 将Blob对象转换为DataURL\n            // 在界面中显示图像\n            item.img = URL.createObjectURL(blob);\n        }).catch((err => {\n            console.log(err);\n        }));\n    },\n}"
    }
  ],
  [
    {
      "id": 6,
      "type": "Java",
      "title": "AES加解密",
      "code": "public static String encode(String contents, String key) {\n\n    if (contents == null || contents.isEmpty()) {\n        return contents;\n    }\n    try {\n        /*\n         * 新建一个密码编译器的实例，由三部分构成，用\"/\"分隔，分别代表如下\n         * 1. 加密的类型(如AES，DES，RC2等)\n         * 2. 模式(AES中包含ECB，CBC，CFB，CTR，CTS等)\n         * 3. 补码方式(包含nopadding/PKCS5Padding等等)\n         * 依据这三个参数可以创建很多种加密方式\n         */\n        Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);\n\n        // 偏移量\n        IvParameterSpec zeroIv = new IvParameterSpec(VIPARA.getBytes(CODE_TYPE));\n\n        byte[] byteContent = contents.getBytes(CODE_TYPE);\n\n        // 使用加密秘钥\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(CODE_TYPE), AES);\n\n        // 初始化为加密模式的密码器\n        cipher.init(Cipher.ENCRYPT_MODE, skeySpec, zeroIv);\n\n        // 加密\n        byte[] result = cipher.doFinal(byteContent);\n\n        // 通过Base64转码返回\n        return Base64.encodeBase64String(result);\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n\n    return null;\n}\n\npublic static String decode(String content, String key) {\n    if (content == null || content.isEmpty()) {\n        return content;\n    }\n\n    try {\n        // 实例化\n        Cipher cipher = Cipher.getInstance(CBC_PKCS5_PADDING);\n        IvParameterSpec zeroIv = new IvParameterSpec(VIPARA.getBytes(CODE_TYPE));\n\n        SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(CODE_TYPE), AES);\n        cipher.init(Cipher.DECRYPT_MODE, skeySpec, zeroIv);\n\n        byte[] result = cipher.doFinal(Base64.decodeBase64(content));\n\n        return new String(result, CODE_TYPE);\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n\n    return null;\n}"
    },
    {
      "id": 7,
      "type": "Java",
      "title": "利用apiType和AES保证接口安全",
      "code": "String json = AESUtil.decode(httpRequestEntity.getData(), AESUtil.KEY);\nString apiType = AESUtil.decode(httpRequestEntity.getApiType(), AESUtil.KEY);\n\n//获得cookie中的token\nString token = null;\nCookie[] cookies = request.getCookies();\nif (cookies != null) {\n    for (Cookie cookie : cookies) {\n        if (\"token\".equals(cookie.getName())) {\n            token = cookie.getValue();\n        }\n    }\n}\n\n//根据apiType判断调用哪个方法\nif (apiType != null) {\n    Long userId = null;\n    //进行登录验证\n    if (apiType.equals(\"ban\") || apiType.equals(\"unban\") || apiType.equals(\"delete\") ||\n            apiType.equals(\"changePassword\") || apiType.equals(\"changeUserInfo\") ||\n            apiType.equals(\"subscribeUser\") || apiType.equals(\"unsubscribeUser\") ||\n            apiType.equals(\"addExperience\")) {\n        if (token == null) {\n            return HttpResponseEntity.code401();\n        }\n        userId = redisUtil.get(token, Long.class);\n        if (userId == null) {\n            return HttpResponseEntity.code401();\n        }\n    }\n\n    logger.info(\"apiType = \" + apiType);\n\n    return switch (apiType) {\n        case \"login\" -> login(json, response);\n        case \"tokenLogin\" -> tokenLogin(request);\n        case \"register\" -> register(json);\n        case \"logout\" -> logout(request, response);\n        case \"ban\" -> ban(json, userId);\n        case \"unban\" -> unban(json, userId);\n        case \"delete\" -> delete(json, userId);\n        case \"changePassword\" -> changePassword(json, userId);\n        case \"changeUserInfo\" -> changeUserInfo(json, userId);\n        case \"getUserInfo\" -> getUserInfo(json);\n        case \"selectUserByPage\" -> selectUserByPage(json);\n        case \"selectUserByPageBigData\" -> selectUserByPageBigData(json);\n        case \"subscribeUser\" -> subscribeUser(json, userId);\n        case \"unsubscribeUser\" -> unsubscribeUser(json, userId);\n        case \"addExperience\" -> addExperience(json, userId);\n        case \"selectUserList\" -> selectUserList(json);\n        default -> HttpResponseEntity.code404();\n    };\n}\nreturn HttpResponseEntity.code404();"
    },
    {
      "id": 8,
      "type": "Java",
      "title": "minio工具方法",
      "code": "public static boolean minioUpload(MultipartFile file, String fileName, String bucketName) {\n    try {\n        MinioClient minioClient = MinioClientConfig.getMinioClient();\n        // 如果fileName为空，则使用源文件名上传\n        if (fileName == null) {\n            fileName = file.getOriginalFilename();\n            if (fileName != null) {\n                fileName = fileName.replaceAll(\" \", \"_\");\n            }\n        }\n        InputStream inputStream = file.getInputStream();\n        PutObjectArgs objectArgs = PutObjectArgs.builder().bucket(bucketName).object(fileName)\n                .stream(inputStream, file.getSize(), -1).contentType(file.getContentType()).build();\n        // 文件名称相同会覆盖\n        minioClient.putObject(objectArgs);\n        return true; // 返回true表示上传成功\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        return false; // 返回false表示上传失败\n    }\n}\n\npublic static byte[] minioDownload(String fileName, String bucketName) {\n    try {\n        MinioClient minioClient = MinioClientConfig.getMinioClient();\n        InputStream inputStream = minioClient.getObject(\n                GetObjectArgs.builder()\n                        .bucket(bucketName)\n                        .object(fileName)\n                        .build()\n        );\n        // 使用 ByteArrayOutputStream 读取输入流数据\n        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n        byte[] buffer = new byte[4096];\n        int bytesRead;\n        while ((bytesRead = inputStream.read(buffer)) != -1) {\n            byteArrayOutputStream.write(buffer, 0, bytesRead);\n        }\n        inputStream.close();\n        // 获取读取的字节数组\n        byte[] bytes = byteArrayOutputStream.toByteArray();\n        byteArrayOutputStream.close();\n        return bytes;\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n        return null;\n    }\n}"
    },
    {
      "id": 9,
      "type": "Java",
      "title": "redis工具方法",
      "code": "public void ping() {\n    redisTemplate.execute(RedisConnectionCommands::ping);\n}\n\npublic void set(String key, Object value, long expire) {\n    valueOperations.set(key, toJson(value));\n    if (expire != NOT_EXPIRE) {\n        redisTemplate.expire(key, expire, TimeUnit.SECONDS);\n    }\n}\n\npublic String get(String key) {\n    return get(key, NOT_EXPIRE);\n}\n\npublic void delete(String key) {\n    redisTemplate.delete(key);\n}"
    },
    {
      "id": 10,
      "type": "Java",
      "title": "雪花算法工具方法",
      "code": "public synchronized long nextId() {\n    long currentTimestamp = System.currentTimeMillis();\n\n    if (currentTimestamp < lastTimestamp) {\n        throw new RuntimeException(\"Clock moved backwards. Refusing to generate id.\");\n    }\n\n    if (currentTimestamp == lastTimestamp) {\n        // 如果在相同毫秒内生成多个ID，通过增加序列号的方式进行区分\n        sequence = (sequence + 1) & ~(-1L << SEQUENCE_BITS);\n        if (sequence == 0) {\n            // 同一毫秒内的序列号已经用完，等待下一毫秒\n            currentTimestamp = waitNextMillis(currentTimestamp);\n        }\n    } else {\n        // 不同毫秒内，序列号重新从0开始\n        sequence = 0L;\n    }\n\n    lastTimestamp = currentTimestamp;\n\n    // 生成最终的64位ID\n    return ((currentTimestamp - START_TIMESTAMP) << TIMESTAMP_SHIFT)\n            | (dataCenterId << DATA_CENTER_ID_SHIFT)\n            | (workerId << WORKER_ID_SHIFT)\n            | sequence;\n}"
    }
  ],
  [
    {
      "id": 11,
      "type": "Java",
      "title": "解决redis和mysql超时断连问题",
      "code": "@Scheduled(fixedDelay = 1000 * 60)\npublic void sendPingRequest() {\n    try {\n        // 发送ping请求\n        redisUtil.ping();\n        pingMapper.ping();\n    } catch (Exception e) {\n        logger.error(e.getMessage(), e);\n    }\n}"
    },
    {
      "id": 12,
      "type": "Mybatis",
      "title": "递归sql解决链式查询",
      "code": "<!-- 根据id获取收藏的章节链 -->\n<select id=\"getCollectSegmentList\" resultMap=\"Segment\">\n    WITH RECURSIVE segment_chain AS\n                       (SELECT s1.id,\n                               s1.tale_id,\n                               s1.user_id,\n                               s1.father_id,\n                               left(s1.content, 10) AS content,\n                               s1.create_time,\n                               s1.update_time,\n                               s1.status,\n                               s1.like_count,\n                               s1.comment_count,\n                               s1.collect_count,\n                               s1.browse_count\n                        FROM segment s1\n                        WHERE s1.id = #{segment_id}\n                        UNION ALL\n                        SELECT s2.id,\n                               s2.tale_id,\n                               s2.user_id,\n                               s2.father_id,\n                               left(s2.content, 10) AS content,\n                               s2.create_time,\n                               s2.update_time,\n                               s2.status,\n                               s2.like_count,\n                               s2.comment_count,\n                               s2.collect_count,\n                               s2.browse_count\n                        FROM segment s2\n                                 INNER JOIN segment_chain ON segment_chain.father_id = s2.id)\n    SELECT *\n    FROM segment_chain\n    order by id;\n</select>"
    },
    {
      "id": 13,
      "type": "Mybatis",
      "title": "相关性搜索查询问题",
      "code": "<!--搜索章节-->\n<select id=\"searchSegmentList\" resultMap=\"Segment\">\n    SELECT s.id,s.title, s.tale_id, t.title as tale_name,t.interface as tale_interface,\n    s.user_id, u.username as user_name, s.father_id,s.content,\n    s.create_time, s.update_time, s.status, s.like_count, s.comment_count, s.collect_count, s.browse_count,\n    (\n    -- Calculate relevance score\n    (IF(s.content LIKE CONCAT('%', #{searchKeyWord}, '%'), 2, 0)\n    ) +\n    (IF(u.username LIKE CONCAT('%', #{searchKeyWord}, '%'), 1, 0)\n    ) +\n    (IF(t.title LIKE CONCAT('%', #{searchKeyWord}, '%'), 1, 0)\n    )\n    ) AS relevance\n    FROM segment s\n    LEFT JOIN tale t ON s.tale_id = t.id\n    LEFT JOIN user u ON s.user_id = u.id\n    WHERE s.content LIKE CONCAT('%', #{searchKeyWord}, '%')\n    OR u.username LIKE CONCAT('%', #{searchKeyWord}, '%')\n    OR t.title LIKE CONCAT('%', #{searchKeyWord}, '%')\n    <if test=\"status != null\">\n        AND s.status = #{status}\n    </if>\n    ORDER BY ${sortType} ${sort}\n    LIMIT #{offset}, #{pageSize}\n</select>"
    },
    {
      "id": 14,
      "type": "Java",
      "title": "登录时将token写入cookie",
      "code": "private HttpResponseEntity login(String json, HttpServletResponse response) {\n    HttpResponseEntity httpResponseEntity = new HttpResponseEntity();\n    User user = new Gson().fromJson(json, User.class);\n    CompletableFuture<User> login = CompletableFuture.supplyAsync(() -> userService.login(user), executor);\n    User result = login.join();\n    if (result != null) {\n\n        //登录成功后，将用户id存入redis\n        String token = UUID.randomUUID().toString();\n        redisUtil.set(token, result.getId(), 60 * 60 * 2);//2小时\n\n        //将token写入cookie\n        if (token != null) {\n            ResponseCookie cookie = ResponseCookie.from(\"token\", token) // key & value\n                    .httpOnly(false)\n                    .secure(false)        // 在http下也传输\n                    .domain(\"localhost\")// 域名\n                    .path(\"/\")            // path\n                    .maxAge(2 * 60 * 60)// 有效期2小时\n                    .sameSite(\"None; Secure\")\n                    .build();\n            response.setHeader(HttpHeaders.SET_COOKIE, cookie.toString()); // 将 cookie 返回给客户端浏览器\n            response.setHeader(\"Access-Control-Expose-Headers\", \"token\");\n\n            httpResponseEntity.setCode(HttpResponseEntity.code200().getCode());\n            httpResponseEntity.setData(AESUtil.encode(new Gson().toJson(result), AESUtil.KEY));\n            httpResponseEntity.setMessage(AESUtil.encode(\"登录成功\", AESUtil.KEY));\n        } else {\n            httpResponseEntity.setCode(HttpResponseEntity.code500().getCode());\n            httpResponseEntity.setData(null);\n            httpResponseEntity.setMessage(AESUtil.encode(\"服务器内部错误\", AESUtil.KEY));\n        }\n    } else {\n        httpResponseEntity.setCode(HttpResponseEntity.code401().getCode());\n        httpResponseEntity.setData(null);\n        httpResponseEntity.setMessage(AESUtil.encode(\"用户名或密码错误\", AESUtil.KEY));\n    }\n    return httpResponseEntity;\n}"
    },
    {
      "id": 15,
      "type": "Vue",
      "title": "滚动分页实现",
      "code": "<div v-if=\"thing==='tale'\" id=\"con\" v-infinite-scroll=\"load\"\n:infinite-scroll-disabled=\"loading || allLoaded\"\n:infinite-scroll-immediate=\"false\" class=\"item-card-container\">"
    }
  ],
  [
    {
      "id": 16,
      "type": "Vue",
      "title": "骨架屏及load效果",
      "code": "<el-skeleton v-else animated>\n    <template #template>\n      <div v-for=\"index in rowsPerPage\" :key=\"index\" class=\"book-row\">\n        <el-card v-for=\"index in itemsPerRow\" :key=\"index\" class=\"book-card\" shadow=\"hover\"\n                 style=\"margin-right: 20px; background: transparent; border: none; box-shadow: none\">\n          <div style=\"display: flex; align-items: center\">\n            <el-skeleton-item style=\"width: 120px; height: 160px; margin-right: 20px\"></el-skeleton-item>\n            <div style=\"display: flex; flex-direction: column; justify-content: space-between\">\n              <div class=\"book-info\">\n                <el-skeleton-item style=\"width: 200px; height: 20px; margin-bottom: 10px\"></el-skeleton-item>\n                <el-skeleton-item style=\"width: 150px; height: 20px; margin-bottom: 10px\"></el-skeleton-item>\n                <el-skeleton-item style=\"width: 200px; height: 20px; margin-bottom: 10px\"></el-skeleton-item>\n                <el-skeleton-item style=\"width: 200px; height: 20px; margin-bottom: 10px\"></el-skeleton-item>\n              </div>\n            </div>\n          </div>\n        </el-card>\n      </div>\n    </template>\n  </el-skeleton>\n</div>\n\n<!--加载动画,在中间小圈-->\n<div v-if=\"loading&&!allLoaded\" style=\"margin-bottom: 50px\">\n  <p v-loading=\"true\" element-loading-text=\"玩命加载中...\"></p>\n</div>"
    },
    {
      "id": 17,
      "type": "Vue",
      "title": "Vue使用Vuex",
      "code": "export default createStore({\n    state: {\n        auto: localStorage.getItem('auto') === 'true',\n        user: null,\n        searchKeyWord: '',\n        cancelToken: [],\n    },\n    mutations: {\n        setUser(state, user) {\n            state.user = user;\n        },\n        setAuto(state, auto) {\n            state.auto = auto;\n            localStorage.setItem('auto', auto);\n        },\n        logout(state) {\n            state.user = null;\n            state.auto = false;\n            localStorage.setItem('auto', 'false');\n        },\n        setSearchKeyWord(state, searchKeyWord) {\n            state.searchKeyWord = searchKeyWord;\n        },\n        pushToken(state, token) {\n            state.cancelToken.push(token);\n        },\n        clearToken(state) {\n            state.cancelToken.forEach((item) => {\n                item();\n            });\n            state.cancelToken = [];\n        },\n    },\n    actions: {\n        setUser(context, user) {\n            context.commit('setUser', user)\n        },\n        setAuto(context, auto) {\n            context.commit('setAuto', auto)\n        },\n        logout(context) {\n            context.commit('setUser', null);\n            context.commit('setAuto', false);\n            this.$cookies.remove('token');\n        },\n        setSearchKeyWord(context, searchKeyWord) {\n            context.commit('setSearchKeyWord', searchKeyWord)\n        },\n        pushToken(context, token) {\n            context.commit('pushToken', token)\n        },\n        clearToken(context) {\n            context.commit('clearToken')\n        }\n    },\n    getters: {\n        getUser(state) {\n            return state.user\n        },\n        getAuto(state) {\n            return state.auto\n        },\n        getSearchKeyWord(state) {\n            return state.searchKeyWord\n        }\n    }\n})"
    },
    {
      "id": 18,
      "type": "Java",
      "title": "filter代码示例",
      "code": "@WebFilter\npublic class LogFilter implements Filter {\n\n    private static final Logger logger = LoggerFactory.getLogger(StoryTreeApplication.class);\n\n    @Override\n    public void init(FilterConfig filterConfig) {\n    }\n\n    /**\n     * 输出访问IP\n     *\n     * @param request  Servlet请求\n     * @param response Servlet响应\n     * @param chain    过滤器链\n     * @throws ServletException 如果发生Servlet异常\n     * @throws IOException      如果发生IO异常\n     */\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException {\n        HttpServletRequest req = (HttpServletRequest) request;\n        logger.info(\"LogFilter, URL: \" + req.getRequestURL() + \", IP: \" + req.getRemoteAddr());\n        chain.doFilter(req, response);\n    }\n\n    @Override\n    public void destroy() {\n    }\n}"
    },
    {
      "id": 19,
      "type": "Vue",
      "title": "Vue3设置全局函数",
      "code": "app.config.globalProperties.$aes = AES;\napp.config.globalProperties.$msg = message;\napp.config.globalProperties.$resource = resource;\napp.config.globalProperties.$utils = utils;"
    },
    {
      "id": 20,
      "type": "Vue",
      "title": "Vue3引入highlight.js",
      "code": "<div class=\"hljs-container\" :codetype=\"item.type\">\n  <!--在右上角添加复制按钮-->\n  <div style=\"text-align: right\">\n    <el-button type=\"text\" class=\"copy-btn\" @click=\"copyCode(item.code)\">\n      <i class=\"el-icon-document-copy\"></i>复制\n    </el-button>\n  </div>\n  <div style=\"display: flex;width: 100%;margin-top: -15px\">\n    <ul class=\"hljs-code-number\">\n      <li class=\"line\" v-for=\"i in lineCount(item.code)\" :key=\"i\">{{ i }}</li>\n    </ul>\n    <highlightjs class=\"hljs\" :codetype=\"Vue\" :code=\"item.code\"></highlightjs>\n  </div>\n</div>\n\n//main.js中\nimport 'highlight.js/styles/androidstudio.css'\nimport 'highlight.js/lib/common'\nimport hljsVuePlugin from '@highlightjs/vue-plugin'"
    }
  ],
  [
    {
      "id": 21,
      "type": "Java",
      "title": "解决数据库日期读取格式问题",
      "code": "public class DatetimeToStringTypeHandler implements TypeHandler<String> {\n    private static final Logger logger = LoggerFactory.getLogger(StoryTreeApplication.class);\n    private final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n\n    @Override\n    public void setParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException {\n        Date date = null;\n        try {\n            date = dateFormat.parse(parameter);\n        } catch (Exception e) {\n            logger.error(e.getMessage(), e);\n        }\n        if (date != null) {\n            ps.setTimestamp(i, new java.sql.Timestamp(date.getTime()));\n        } else {\n            ps.setTimestamp(i, null);\n        }\n    }\n\n    @Override\n    public String getResult(ResultSet rs, String columnName) throws SQLException {\n        return formatDatetime(rs.getTimestamp(columnName));\n    }\n\n    @Override\n    public String getResult(ResultSet rs, int columnIndex) throws SQLException {\n        return formatDatetime(rs.getTimestamp(columnIndex));\n    }\n\n    @Override\n    public String getResult(CallableStatement cs, int columnIndex) throws SQLException {\n        return formatDatetime(cs.getTimestamp(columnIndex));\n    }\n\n    /**\n     * 格式化日期时间\n     *\n     * @param timestamp 要格式化的日期时间\n     * @return 格式化后的日期时间字符串\n     */\n    private String formatDatetime(java.sql.Timestamp timestamp) {\n        if (timestamp != null) {\n            return dateFormat.format(timestamp);\n        }\n        return null;\n    }\n}"
    },
    {
      "id": 22,
      "type": "Markdown",
      "title": "环境部署相关指令",
      "code": "## 项目启动\n\n### java -jar target/StoryTree-0.0.1-SNAPSHOT.jar 运行\n\n### nohup java -jar StoryTree-0.0.1-SNAPSHOT.jar & 后台运行\n\n### ctrl + c 退j出\n\n## 启动Redis\n\n### /usr/local/redis/bin/redis-server /usr/local/redis/bin/redis.conf\n\n## 关闭Redis\n\n### ps -ef | grep redis\n\n### kill -9 xxxx\n\n## 查看内存\n\n### free -m\n\n## 启动nginx\n\n### /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf\n\n## 关闭nginx\n\n### /usr/local/nginx/sbin/nginx -s stop\n\n## 指定端口后台启动minio\n\n### nohup ./minio server --console-address :9100 --address :9000 ./data &\n\n## 关闭minio\n\n### ps -ef | grep minio\n\n### kill -9 xxxx\n\n## 后台启动sonarqube（非root用户）\n\n### sysctl -w vm.max_map_count=262144 修改内存\n\n### nohup ./sonar.sh start -Des.enforce.bootstrap.checks=true &\n\n## 关闭sonarqube\n\n### ./sonar.sh stop\n\n## 开放端口\n\n### firewall-cmd --zone=public --add-port=xxxx/tcp --permanent\n\n### firewall-cmd --reload\n\n### firewall-cmd --list-ports\n\n## 杀死进程\n\n### lsof -i:xxxx\n\n### kill -9 xxxx"
    },
    {
      "id": 23,
      "type": "Java",
      "title": "springboot集成redis集群",
      "code": "    redis:\n      database: 0\n      cluster:\n        nodes: 101.43.255.130:6349,101.43.255.130:6359,101.43.255.130:6369,101.43.255.130:6379,101.43.255.130:6389,101.43.255.130:6399\n        max-redirects: 3\n      password: 20030321\n      timeout: 4000\n      jedis:\n        pool:\n          max-active: 64\n          max-wait: 2000\n          max-idle: 16\n          min-idle: 4\n\n    @Bean\n    public RedisClusterConfiguration redisClusterConfiguration() {\n        RedisClusterConfiguration redisClusterConfiguration = new RedisClusterConfiguration();\n        String[] hosts = host.split(\",\");\n        Set<RedisNode> nodeList = new HashSet<>();\n        for (String hostAndPort : hosts) {\n            String[] hostOrPort = hostAndPort.split(\":\");\n            nodeList.add(new RedisNode(hostOrPort[0], Integer.parseInt(hostOrPort[1])));\n        }\n        redisClusterConfiguration.setClusterNodes(nodeList);\n        redisClusterConfiguration.setPassword(password);\n        redisClusterConfiguration.setMaxRedirects(maxRedirects);\n        return redisClusterConfiguration;\n    }\n\n    @Bean\n    @SuppressWarnings(\"deprecation\")\n    public JedisPoolConfig jedisPoolConfig() {\n        JedisPoolConfig poolConfig = new JedisPoolConfig();\n        poolConfig.setMaxIdle(this.maxIdle);\n        poolConfig.setMinIdle(this.minIdle);\n        poolConfig.setMaxTotal(this.maxTotal);\n        poolConfig.setMaxWaitMillis(this.maxWaitMillis);\n        poolConfig.setTestOnCreate(true);\n        poolConfig.setTestOnBorrow(true);\n        poolConfig.setTestOnReturn(true);\n        poolConfig.setTestWhileIdle(true);\n        return poolConfig;\n    }\n\n    @Bean(\"myJedisConnectionFactory\")\n    @SuppressWarnings(\"deprecation\")\n    public JedisConnectionFactory jedisConnectionFactory(RedisClusterConfiguration redisClusterConfiguration,\n                                                         JedisPoolConfig jedisPoolConfig) {\n        JedisConnectionFactory jedisConnectionFactory = new JedisConnectionFactory(\n                redisClusterConfiguration, jedisPoolConfig);\n        jedisConnectionFactory.setTimeout(timeout);\n        return jedisConnectionFactory;\n    }"
    },
    {
      "id": 24,
      "type": "Java",
      "title": "springboot集成caffeine缓存",
      "code": "public class CaffeineCacheInitializer {\n\n    public static List<CaffeineCache> initCaffeineCache() {\n        List<CaffeineCache> caffeineCacheList = new ArrayList<>();\n\n        CaffeineCache userCache = new CaffeineCache(CacheKey.USER_CACHE_KEY, Caffeine.newBuilder().recordStats()\n                .expireAfterWrite(CacheExpire.USER_CACHE_EXPIRE, TimeUnit.SECONDS)\n                .initialCapacity(10)\n                .maximumSize(100)\n                .build());\n        caffeineCacheList.add(userCache);\n\n        CaffeineCache storyCache = new CaffeineCache(CacheKey.TALE_CACHE_KEY, Caffeine.newBuilder().recordStats()\n                .expireAfterWrite(CacheExpire.TALE_CACHE_EXPIRE, TimeUnit.SECONDS)\n                .initialCapacity(50)\n                .maximumSize(250)\n                .build());\n        caffeineCacheList.add(storyCache);\n\n        CaffeineCache segmentCache = new CaffeineCache(CacheKey.SEGMENT_CACHE_KEY, Caffeine.newBuilder().recordStats()\n                .expireAfterWrite(CacheExpire.SEGMENT_CACHE_EXPIRE, TimeUnit.SECONDS)\n                .initialCapacity(250)\n                .maximumSize(1250)\n                .build());\n        caffeineCacheList.add(segmentCache);\n\n        CaffeineCache commentCache = new CaffeineCache(CacheKey.COMMENT_CACHE_KEY, Caffeine.newBuilder().recordStats()\n                .expireAfterWrite(CacheExpire.COMMENT_CACHE_EXPIRE, TimeUnit.SECONDS)\n                .initialCapacity(500)\n                .maximumSize(1000)\n                .build());\n        caffeineCacheList.add(commentCache);\n\n        CaffeineCache messageCache = new CaffeineCache(CacheKey.MESSAGE_CACHE_KEY, Caffeine.newBuilder().recordStats()\n                .expireAfterWrite(CacheExpire.MESSAGE_CACHE_EXPIRE, TimeUnit.SECONDS)\n                .initialCapacity(1000)\n                .maximumSize(2000)\n                .build());\n        caffeineCacheList.add(messageCache);\n\n        CaffeineCache resourceCache = new CaffeineCache(CacheKey.RESOURCE_CACHE_KEY, Caffeine.newBuilder().recordStats()\n                .expireAfterWrite(CacheExpire.RESOURCE_CACHE_EXPIRE, TimeUnit.SECONDS)\n                .initialCapacity(100)\n                .maximumSize(500)\n                .build());\n        caffeineCacheList.add(resourceCache);\n\n        return caffeineCacheList;\n    }\n}\n\n/**\n * CaffeineCache配置类\n */\n@Configuration\n@EnableCaching\npublic class CaffeineCacheConfig {\n\n    @Bean\n    @Primary\n    public CacheManager caffeineCacheManager() {\n        SimpleCacheManager cacheManager = new SimpleCacheManager();\n        List<CaffeineCache> caches = CaffeineCacheInitializer.initCaffeineCache();\n        if (CollectionUtils.isEmpty(caches)) {\n            return cacheManager;\n        }\n        cacheManager.setCaches(caches);\n        return cacheManager;\n    }\n\n}\n\n/*\n * 自定义缓存key生成策略\n */\n@Component(\"selfKeyGenerate\")\npublic class SelfKeyGenerate implements KeyGenerator {\n    @NotNull\n    @Override\n    public Object generate(Object target, Method method, @NotNull Object... params) {\n        return target.getClass().getSimpleName() + \"#\" + method.getName() +\n                \"(\" + new Gson().toJson(params) + \")\";\n    }\n}\n\n/**\n     * 登录\n     *\n     * @param user 用户对象\n     * @return 用户对象，登录成功返回用户信息，登录失败返回null\n     */\n    @Override\n    @Cacheable(value = CacheKey.USER_CACHE_KEY, keyGenerator = \"selfKeyGenerate\")\n    public User login(User user) {\n        User redisUser = redisUtil.get(\"user:\" + user.getId(), User.class);\n        if (redisUser != null) {\n            logger.info(\"get data from redis cache: \" + redisUser);\n            return redisUser;\n        }\n        User userFromDatabase = userMapper.login(user);\n        if (userFromDatabase != null) {\n            redisUtil.set(\"user:\" + user.getId(), userFromDatabase, CacheExpire.USER_CACHE_EXPIRE * 2);\n        } else {\n            redisUtil.set(\"user:\" + user.getId(), \"null\", CacheExpire.USER_CACHE_EXPIRE);\n        }\n        return userFromDatabase;\n    }"
    },
    {
      "id": 25,
      "type": "Java",
      "title": "springboot集成redis缓存",
      "code": "@Bean\n    public CacheManager cacheManager(@Qualifier(\"myJedisConnectionFactory\") JedisConnectionFactory jedisConnectionFactory) {\n        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig();\n        RedisCacheConfiguration redisCacheConfiguration = config\n                .serializeKeysWith(\n                        RedisSerializationContext.SerializationPair\n                                .fromSerializer(new StringRedisSerializer()))\n                .serializeValuesWith(\n                        RedisSerializationContext.SerializationPair\n                                .fromSerializer(new GenericJackson2JsonRedisSerializer()));\n\n        return RedisCacheManager.builder(jedisConnectionFactory)\n                .cacheDefaults(redisCacheConfiguration).build();\n    }\n\n/**\n     * token登录\n     *\n     * @param userId 用户ID\n     * @return 用户对象，登录成功返回用户信息，登录失败返回null\n     */\n    @Override\n    @Cacheable(value = CacheKey.USER_CACHE_KEY, keyGenerator = \"selfKeyGenerate\")\n    public User tokenLogin(long userId) {\n        User redisUser = redisUtil.get(\"user:\" + userId, User.class);\n        if (redisUser != null) {\n            logger.info(\"get data from redis cache: \" + redisUser);\n            return redisUser;\n        }\n        User userFromDatabase = userMapper.tokenLogin(userId);\n        if (userFromDatabase != null) {\n            redisUtil.set(\"user:\" + userId, userFromDatabase, CacheExpire.USER_CACHE_EXPIRE * 2);\n        } else {\n            redisUtil.set(\"user:\" + userId, \"null\", CacheExpire.USER_CACHE_EXPIRE);\n        }\n        return userFromDatabase;\n    }"
    }
  ],
  [
    {
      "id": 26,
      "type": "Mabatis",
      "title": "mybatis防止sql注入",
      "code": "<!--查询故事相关-->\n    <select id=\"searchTaleByPage\" resultMap=\"Tale\">\n        SELECT\n        t.id, t.user_id, t.title, t.type, t.intro, t.interface, t.comment_count, t.like_count, t.collect_count,\n        t.browse_count, t.update_time, u.username,\n        (\n        (IF(t.title LIKE CONCAT('%', #{searchKeyWord}, '%'), 2, 0)\n        ) +\n        (IF(u.username LIKE CONCAT('%', #{searchKeyWord}, '%'), 1, 0)\n        ) +\n        (IF(t.intro LIKE CONCAT('%', #{searchKeyWord}, '%'), 1, 0)\n        ) +\n        (IF(t.id IN (SELECT tale_id FROM tale_tag WHERE tag LIKE CONCAT('%', #{searchKeyWord}, '%')), 1, 0)\n        ) +\n        (IF(t.type LIKE CONCAT('%', #{searchKeyWord}, '%'), 1, 0)\n        )\n        ) AS relevance\n        FROM tale t\n        LEFT JOIN user u ON t.user_id = u.id\n        WHERE (t.title LIKE CONCAT('%', #{searchKeyWord}, '%') OR u.username LIKE CONCAT('%', #{searchKeyWord}, '%'))\n        OR t.intro LIKE CONCAT('%', #{searchKeyWord}, '%')\n        OR t.id IN (SELECT tale_id FROM tale_tag WHERE tag LIKE CONCAT('%', #{searchKeyWord}, '%'))\n        OR t.type LIKE CONCAT('%', #{searchKeyWord}, '%')\n        <if test=\"status != null\">\n            AND t.status = #{status}\n        </if>\n        ORDER BY\n        <choose>\n            <when test=\"sortType == 'time'\">\n                t.update_time\n            </when>\n            <when test=\"sortType == 'relevance'\">\n                relevance\n            </when>\n            <when test=\"sortType == 'count'\">\n                t.collect_count * 20 + t.comment_count * 15 + t.like_count * 5 + t.browse_count * 2\n            </when>\n            <otherwise>\n                t.update_time\n            </otherwise>\n        </choose>\n        <choose>\n            <when test=\"sort == 'desc'\">\n                DESC\n            </when>\n            <when test=\"sort == 'asc'\">\n                ASC\n            </when>\n            <otherwise>\n                ASC\n            </otherwise>\n        </choose>\n        LIMIT #{offset}, #{pageSize}\n    </select>"
    },
    {
      "id": 27,
      "type": "conf",
      "title": "redis集群搭建",
      "code": "redis集群搭建\n\n前提需要安装ruby环境，gem install redis\n\nclient.rb添加password\n\nsrc/redis-trib.rb creat --replicas 1 101.43.255.130:6349 101.43.255.130:6359 101.43.255.130:6369 101.43.255.130:6379 101.43.255.130:6389 101.43.255.130:6399\n\n3主3从，共六个配置文件示例如下：\n#bind 101.43.255.130\nport 6379\nprotected-mode no\ndaemonize yes\npidfile /usr/local/redis/bin/cluster/pid/redis_6379.pid\nappendonly yes\ncluster-enabled yes\ncluster-config-file nodes-6379.conf\ncluster-node-timeout 15000\nmaxmemory 512MB\nmaxmemory-policy allkeys-lru\nrequirepass 20030321\nmasterauth 20030321\n\n清除redis集群缓存\nflushall、 cluster reset\n\nnodes-6379.conf要更改内网ip"
    },
    {
      "id": 28,
      "type": "conf",
      "title": "nacos集群搭建",
      "code": "nacos集群搭建（redis、nacos开放除自身端口外的其他端口）\n\napplication.properties配置mysql\n\nspring.datasource.platform=mysql\ndb.num=1\ndb.url.0=jdbc:mysql://101.43.255.130:3306/nacos_config?characterEncoding=utf8&autoReconnect=true&serverTimezone=Asia/Shanghai\ndb.user=root\ndb.password=20030321lzy\n\ncluster.conf示例：\n10.0.8.6:8878\n101.43.255.130:8858\n101.43.255.130:8868\n101.43.255.130:8878"
    },
    {
      "id": 28,
      "type": "conf",
      "title": "mysql多实例搭建",
      "code": "[mysqld_multi]\nmysqld = /usr/local/mysql/bin/mysqld_safe\nmysqladmin = /usr/local/mysql/bin/mysqladmin\nuser = root\n[mysqld1]\nbasedir = /usr/local/mysql\ndatadir = /usr/local/mysql/mysqldb\nport = 3306\nlog-error = /usr/local/mysql/mysqldb/mysqld.err\npid-file = /usr/local/mysql/mysqldb/mysqld.pid\nsocket = /usr/local/mysql/mysqldb/mysqld.sock\n[mysqld2]\nbasedir = /usr/local/mysql\ndatadir = /usr/local/mysql/data\nport = 3316\nlog-error = /usr/local/mysql/data/mysqld2.err\npid-file = /usr/local/mysql/data/mysqld2.pid\nsocket = /usr/local/mysql/data/mysqld2.sock\n\n\n# 启动mysql实例\n/usr/local/mysql/bin/mysqld_multi start x\n# 通过socket连接并修改密码\nmysqladmin -uroot -p'#(iaqwiLy3lr' -S /usr/local/mysql/data/mysqld2.sock password '20030321lzy'\nmysqladmin: [Warning] Using a password on the command line interface can be insecure.                                                                                                                                                                                         \nWarning: Since password will be sent to server in plain text, use ssl connection to ensure password safety.\n\n\n# 登录mysql\nmysql -h127.0.0.1 -uroot -p20030321lzy -P3326\n\n\n# 赋予权限\nuse mysql;\ncreate user 'root'@'%' identified by '20030321lzy';\n# 允许所有 ip 远程访问(危险！)\ngrant all privileges on *.* to 'root'@'%' with grant option;\n# 刷新数据库\nFLUSH PRIVILEGES;\n# 查看数据库中的用户权限表\nselect User,authentication_string,Host from user;\n"
    },
    {
      "id": 28,
      "type": "sql",
      "title": "mysql主从复制配置",
      "code": "# 主服务器\nserver-id = 10\nlog-bin=master-bin\nlog-slave-updates=true\n\n# 从服务器\nserver-id = 20\nrelay-log=relay-log-bin  ##从主服务器上同步日志文件记录到本地\nrelay-log-index=slave-relay-bin-index    ##定义relay-log的位置和名称\n\ncreate user 'slave'@'%' identified by '20030321lzy';\ngrant replication slave on *.* to 'slave'@'%' with grant option;\n\nshow master status;   ##查看主服务器的状态。在这个状态下就尽量不要再进行操作，否则回导致位置点变化，发生错位\n\nchange master to master_host ='101.43.255.130',master_port =3306,master_user ='slave',master_password ='20030321lzy',master_log_file ='master-bin.000001',master_log_pos =156;\nstart slave;\nshow slave status;\n# 结果：Slave_IO_Running: Yes,Slave_SQL_Running: Yes(这两个线程一定要处于开启状态)"
    },
    {
      "id": 29,
      "type": "Java",
      "title": "mysql读写分离配置",
      "code": "@Configuration\npublic class ShardingsphereConfig {\n\n    @Value(\"${spring.shardingsphere.datasource.master.url}\")\n    private String masterUrl;\n\n    @Value(\"${spring.shardingsphere.datasource.master.username}\")\n    private String masterUsername;\n\n    @Value(\"${spring.shardingsphere.datasource.master.password}\")\n    private String masterPassword;\n\n    @Value(\"${spring.shardingsphere.datasource.master.driver-class-name}\")\n    private String masterDriverClassName;\n\n    @Value(\"${spring.shardingsphere.datasource.slave0.url}\")\n    private String slave0Url;\n\n    @Value(\"${spring.shardingsphere.datasource.slave0.username}\")\n    private String slave0Username;\n\n    @Value(\"${spring.shardingsphere.datasource.slave0.password}\")\n    private String slave0Password;\n\n    @Value(\"${spring.shardingsphere.datasource.slave0.driver-class-name}\")\n    private String slave0DriverClassName;\n\n    @Value(\"${spring.shardingsphere.datasource.slave1.url}\")\n    private String slave1Url;\n\n    @Value(\"${spring.shardingsphere.datasource.slave1.username}\")\n    private String slave1Username;\n\n    @Value(\"${spring.shardingsphere.datasource.slave1.password}\")\n    private String slave1Password;\n\n    @Value(\"${spring.shardingsphere.datasource.slave1.driver-class-name}\")\n    private String slave1DriverClassName;\n\n    /**\n     * 配置数据源信息\n     *\n     * @return 数据源\n     */\n    public DataSource druidDataSource(String url, String username, String password, String driverClassName) throws SQLException {\n        DruidDataSource dds = new DruidDataSource();\n        dds.setUrl(url);\n        dds.setUsername(username);\n        dds.setPassword(password);\n        dds.setDriverClassName(driverClassName);\n        dds.setInitialSize(5);                                  /* 初始化时建立物理连接的个数 */\n        dds.setMaxActive(20);                                   /* 最大连接池数量 */\n        dds.setMaxWait(60000);                                  /* 获取连接时最大等待时间，单位毫秒 */\n        dds.setMinIdle(8);                                      /* 最小连接池数量 */\n        dds.setTimeBetweenEvictionRunsMillis(60000);            /* Destroy线程会检测连接的间隔时间 */\n        dds.setMinEvictableIdleTimeMillis(300000);              /* 连接保持空闲而不被驱逐的最小时间 */\n        dds.setValidationQuery(\"SELECT 1 FROM DUAL\");           /* 用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。 */\n        dds.setTestWhileIdle(true);                             /* 建议配置为true，不影响性能，并且保证安全性 */\n        dds.setTestOnBorrow(false);                             /* 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 */\n        dds.setTestOnReturn(false);                             /* 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能 */\n        dds.setPoolPreparedStatements(false);                   /* 是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，比如说oracle。在mysql下建议关闭 */\n        dds.setFilters(\"stat,wall\");                            /* 属性类型是字符串，通过别名的方式配置扩展插件，常用的插件有：监控统计用的filter:stat, 日志用的filter:log4j, 防御sql注入的filter:wall */\n        dds.setMaxPoolPreparedStatementPerConnectionSize(50);   /* 要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100 */\n        dds.setUseGlobalDataSourceStat(true);\n        Properties properties = new Properties();\n        properties.setProperty(\"druid.stat.mergeSql\", \"true\");\n        properties.setProperty(\"druid.stat.slowSqlMillis\", \"100\");\n        dds.setConnectProperties(properties);\n        dds.setDbType(\"mysql\");//mysql必须小写\n        return dds;\n    }\n\n    /**\n     * 配置数据源信息\n     *\n     * @return 数据源\n     */\n    @Bean\n    public ShardingRuleConfiguration shardingRuleConfiguration() {\n        ShardingRuleConfiguration config = new ShardingRuleConfiguration();\n        LoadBalanceStrategyConfiguration loadConfiguration = new LoadBalanceStrategyConfiguration(\"round_robin\");\n        MasterSlaveRuleConfiguration configuration = new MasterSlaveRuleConfiguration(\"dataSource\",\n                \"master\", List.of(\"slave0\", \"slave1\"),\n                loadConfiguration\n        );\n        config.setMasterSlaveRuleConfigs(List.of(configuration));\n        return config;\n    }\n\n    /**\n     * 配置数据源信息\n     *\n     * @return 数据源\n     */\n    @Bean\n    public DataSource shardingDataSource(ShardingRuleConfiguration configuration) throws SQLException {\n        DataSource masterDataSource = druidDataSource(masterUrl, masterUsername, masterPassword, masterDriverClassName);\n        DataSource slave0DataSource = druidDataSource(slave0Url, slave0Username, slave0Password, slave0DriverClassName);\n        DataSource slave1DataSource = druidDataSource(slave1Url, slave1Username, slave1Password, slave1DriverClassName);\n\n        Map<String, DataSource> dataSourceMap = new HashMap<>();\n        dataSourceMap.put(\"master\", masterDataSource);\n        dataSourceMap.put(\"slave0\", slave0DataSource);\n        dataSourceMap.put(\"slave1\", slave1DataSource);\n\n        DataSource shardingDataSource;\n        Properties props = new Properties();\n        props.put(\"sql.show\", true);\n        try {\n            shardingDataSource = ShardingDataSourceFactory.createDataSource(dataSourceMap, configuration, props);\n        } catch (SQLException e) {\n            throw new RuntimeException(e);\n        }\n        return shardingDataSource;\n    }\n}"
    }
  ]
]
